---
title: "Statistical Analyses of Juglans nigra Phlomem Fungal Communities"
author: "Aaron Onufrak"
output: rmdformats::downcute
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction

## Background

Thousand cankers disease (TCD) is caused by the fungal pathogen *Geosmithia morbida* and its insect vector *Pityophthorous juglandis* (walnut twig beetle; WTB). The most susceptible TCD host is *Juglans nigra* (eastern black walnut) an important timber and nut crop native to  portions of the eastern and midwestern U.S. TCD has been detected in 15 U.S. states and portions of Italy.

At this time, the effects of *G. morbida* infection on the  *J. nigra* microbiome are not well understood. Therefore, the **objective of this study was to examine  the effects of *G.moribida* infection on the *J. nigra* phloem microbial communities**. **We expected that the bacterial communities associated with *J. nigra* phloem tissues would shift in response to G. morbida infection**.

## Study Design
In the nursery compound at the University of Tennessee Knoxville trees were treated with the following three treatments with 24 trees per treatment:

1. Water Control
2. [Phospho-Jet (Phosphorous Acid-based Fungicide, Arborjet)](https://arborjet.com/product/phospho-jet/)
3. [Rootshield (*Trichoderma afroharzianum* strain T-22, BioWorks)](https://www.bioworksinc.com/rootshield-wp/)

Of the 72 trees, 36 trees were inoculated with the fungal pathogen *Geosmithia morbida* isolate TN17 at four separate, equally spaced locations along the stem. This isolate was chosen because it was originally isolated from black walnut in TN and its genome has been sequenced. The remaining 36 trees were inoculated with a potato dextrose agar (PDA) plug to use as an inoculation control. Inoculations took place 7 days following application of Phospho-Jet, Rootshield, and water treatments. On days 14, 28, and 56 post treatment application, trees were destructively sampled with roots and stem tissues sampled for DNA and RNA extraction. 

## Sample Processing

DNA was extracted from phloem tissues using a CTAB method. Extracted DNA was amplified for the ITS2 region using the primers described in [Cregger et al. 2018](https://microbiomejournal.biomedcentral.com/articles/10.1186/s40168-018-0413-8) and sequenced on the Illumina MiSeq platform using 2x250 bp chemistry. Sequences were processed into amplicon sequence variants (ASVs) using the dada2 pipeline. Description of the sequence processing can be found in the [aonufrak/tcd_host_pathogen_interactions repository](https://github.com/aonufrak/tcd_host_pathogen_interactions/tree/main)  including the [original r code](https://github.com/aonufrak/tcd_host_pathogen_interactions/blob/main/amplicon_sequencing_r_analyses/its2.phloem_amplicon_sequence_processing.Rmd) and the knitted [html document](https://github.com/aonufrak/tcd_host_pathogen_interactions/blob/main/amplicon_sequencing_r_analyses/its2.phloem_amplicon_sequence_processing.html).

# Load Packages

Loading the packages required to complete the following analyses. 

```{r}
library(vegan)
library(dplyr)
library(ggplot2)
library(tidyr)
library(ape)
library(pime)
library(phyloseq)
library(hillR)
library(ggpubr)
library(reticulate)
library(ANCOMBC)
library(stringr)
library(nlme)
library(emmeans)
```

# Generating Functions

Creating custom functions to be used for statistical analyses. 

## Rarefy Table Function

The below function takes a rarfied table as input and removes samples that do not have the minimum sampling depth and any ASV that has a sum across samples of zeros following rarefaction. The function takes as input the following items: 

1. **rarefied_table**: a rarefied ASV table with unrarefied samples and zero sum ASVs still present
2. **sample**: sequencing depth by which all samples were rarefied.

```{r}
# Removing unrarefied samples (those less than the minimum sequencing depth). Removing ASVs present in the ASV table that were only present in samples removed following rarefaction. These ASVs will have column sums of 0. 
rarefy_formatting<-function(nonrarefied_asv_tab,sample){
  rarefied_table<-suppressWarnings(as.data.frame(rrarefy(nonrarefied_asv_tab, sample=sample)))
  ds.rarefied<-as.data.frame(subset(rarefied_table, rowSums(rarefied_table)>=sample))
  ds.rare.asv<-ds.rarefied[,colSums(ds.rarefied)>0]
  if(all(rowSums(ds.rare.asv)==sample)){
    print(paste0("All samples rarefied to ",sample))
  }
  return(ds.rare.asv)
}
```

## PCoA and Ordination Function

The below function wraps the vegdist function from vegan and the pcoa function from ape and generates an ordination using ggplot. The results of the PCoA and the ggplot are stored in a two object list. The first is the PCoA output and the second is the ggplot that can be further customized using ggplot arguments. The function requires the following input:

1. **table**: a rarefied ASV table
2. **method**: a method for computing distances (see: ??vegan::vegdist for options)
3. **point_ellipse_color**: The variable by which points and ellipses should be colored
4. **shape**: Shaping variable
5. **polygon**: Logical value indiciating whether filled ellipses should be plotted to reprsented. This is useful when working with data with multiple factors. **Must be specified with ellipse_fill has a value.** 
6. **ellipse_fill**: Variable by which filled ellipses should be colored. 
7. **point_size**: Size of points for ordination. Default is 3.5

```{r}
pcoa_imager<-function(table,method,point_ellipse_color,shape=NULL,polygon=NULL,ellipse_fill=NULL,point_size=3.5){
  column_grabber<-`[[` # Generating a subsetting function
  point_ellipse_color<-column_grabber(table,point_ellipse_color) # will subset the column that contains the provided variable by which points and ellipses should be colored
  ellipse_fill<-column_grabber(table,ellipse_fill) # will subset the column that contains the variabe by which ellipses will be filled
  shape<-column_grabber(table,shape) # will subset the column that contains the point shaping variabe 
  relabund.asv<-decostand(Filter(x=table,f=is.numeric), method="total") # using the decostand function from vegan to convert count data to relative abundances
  dist.asv<-vegdist(relabund.asv, method=method) # calculating distance matrix using the vegdist function from vegan. Method is a user specified variable to indicate which method for computing distance to be used. 
  pcoa.asv<-pcoa(dist.asv) # using the pcoa function from ape to perform a PCoA with the distance matrix stored in dist.asv. 
  pcoavec.asv<-as.data.frame(pcoa.asv$vectors) # creating a dataframe that only includes the vectors from the PCoA.
  pcoasitescores.asv<-data.frame(PC1=pcoavec.asv$Axis.1, PC2=pcoavec.asv$Axis.2) # creating a datatable that is only the first and second PCs. 
  
  # creating a if/else statement based on presence of ellipse_fill. 
      if (is.null(ellipse_fill)){
      pcoagraph.asv<-data.frame(pcoasitescores.asv,PC1=pcoasitescores.asv$PC1, PC2=pcoasitescores.asv$PC2, color=point_ellipse_color, shape_var=shape)
    } else {
  pcoagraph.asv<-data.frame(pcoasitescores.asv,PC1=pcoasitescores.asv$PC1, PC2=pcoasitescores.asv$PC2, color=point_ellipse_color, ellipse_fill=ellipse_fill, shape_var=shape)}
  
  # Generates standard deviation ellipses based on color variable
  pcoaellipse<-ordiellipse(pcoasitescores.asv,pcoagraph.asv$color, display="sites", kind="sd", draw="none")
  ell <- data.frame()
for(g in levels(as.factor(pcoagraph.asv$color))){
ell <- rbind(ell, cbind(as.data.frame(with(pcoagraph.asv[pcoagraph.asv$color==g,],                                                vegan:::veganCovEllipse(pcoaellipse[[g]]$cov,pcoaellipse[[g]]$center,pcoaellipse[[g]]$scale))) ,color=g))}
  
  # Generates secondary ellipse for second color
pcoaellipse.2<-ordiellipse(pcoasitescores.asv,pcoagraph.asv$ellipse_fill, display="sites", kind="sd", draw="none")
  ell_2 <- data.frame()
for(g in levels(as.factor(pcoagraph.asv$ellipse_fill))){
ell_2 <- rbind(ell_2, cbind(as.data.frame(with(pcoagraph.asv[pcoagraph.asv$elllipse_fill==g,],                                                vegan:::veganCovEllipse(pcoaellipse.2[[g]]$cov,pcoaellipse.2[[g]]$center,pcoaellipse.2[[g]]$scale))) ,ellipse_fill=g))}  
  
# Plotting first two PCs of PCoA in ggplot  
  
  # If an ellipse_fill variable is present polygon must be set to true
  if (polygon==TRUE){
  # If statement that indicates what to do in the absence of a shape variable
    if (is.null(shape)){
      pcoa_plot<-ggplot(pcoagraph.asv, aes(PC1,PC2, colour=color))+
      geom_point(size=point_size)+
      geom_path(data=ell, aes(x=PC1, y=PC2, colour=color),linewidth=0.5, linetype=1)+
  geom_polygon(data=ell_2, aes(x=PC1, y=PC2, fill=ellipse_fill),linewidth=0.5, linetype=2,inherit.aes = FALSE,alpha=0.1)+
  theme(axis.title.x=element_text(size=14, face="bold"))+
  theme(axis.title.y=element_text(size=14, face="bold"))+
  theme(axis.text.x=element_text(size=12, face="bold"))+
  theme(axis.text.y=element_text(size=12, face="bold"))+ 
  theme(panel.grid.major=element_blank(),
        panel.grid.minor=element_blank(),
    panel.border=element_rect(colour="black", linewidth =1, fill=NA),
    panel.background = element_rect(fill="white"))+
    xlab(paste0("PC1"," (",round(column_grabber(pcoa.asv,"values")[1,2]*100,2),"%)"))+
    ylab(paste0("PC2"," (",round(column_grabber(pcoa.asv,"values")[2,2]*100,2),"%)"))
   
       } else {
  pcoa_plot<-ggplot(pcoagraph.asv, aes(PC1,PC2, colour=color))+       
  geom_point(aes(shape=shape_var),size=point_size)+
  geom_path(data=ell, aes(x=PC1, y=PC2, colour=color),linewidth=0.5, linetype=1)+
  geom_polygon(data=ell_2, aes(x=PC1, y=PC2, fill=ellipse_fill),linewidth=0.5, linetype=2,inherit.aes = FALSE,alpha=0.1)+
  theme(axis.title.x=element_text(size=14, face="bold"))+
  theme(axis.title.y=element_text(size=14, face="bold"))+
  theme(axis.text.x=element_text(size=12, face="bold"))+
  theme(axis.text.y=element_text(size=12, face="bold"))+ 
  theme(panel.grid.major=element_blank(),
        panel.grid.minor=element_blank(),
    panel.border=element_rect(colour="black", linewidth =1, fill=NA),
    panel.background = element_rect(fill="white"))+
    xlab(paste0("PC1"," (",round(column_grabber(pcoa.asv,"values")[1,2]*100,2),"%)"))+
    ylab(paste0("PC2"," (",round(column_grabber(pcoa.asv,"values")[2,2]*100,2),"%)"))}
         
    } else {
      
      if (is.null(shape)){
      pcoa_plot<-ggplot(pcoagraph.asv, aes(PC1,PC2, colour=color))+
      geom_point(size=point_size)+
      geom_path(data=ell, aes(x=PC1, y=PC2, colour=color),linewidth=0.5, linetype=1)+
  theme(axis.title.x=element_text(size=14, face="bold"))+
  theme(axis.title.y=element_text(size=14, face="bold"))+
  theme(axis.text.x=element_text(size=12, face="bold"))+
  theme(axis.text.y=element_text(size=12, face="bold"))+ 
  theme(panel.grid.major=element_blank(),
        panel.grid.minor=element_blank(),
    panel.border=element_rect(colour="black", linewidth =1, fill=NA),
    panel.background = element_rect(fill="white"))+
    xlab(paste0("PC1"," (",round(column_grabber(pcoa.asv,"values")[1,2]*100,2),"%)"))+
    ylab(paste0("PC2"," (",round(column_grabber(pcoa.asv,"values")[2,2]*100,2),"%)"))
      
        } else {
 pcoa_plot<-ggplot(pcoagraph.asv, aes(PC1,PC2, colour=color))+ 
  geom_point(aes(shape=shape_var), size=point_size)+
  geom_path(data=ell, aes(x=PC1, y=PC2, colour=color),linewidth=0.5, linetype=1)+
 theme(axis.title.x=element_text(size=14, face="bold"))+
  theme(axis.title.y=element_text(size=14, face="bold"))+
  theme(axis.text.x=element_text(size=12, face="bold"))+
  theme(axis.text.y=element_text(size=12, face="bold"))+ 
  theme(panel.grid.major=element_blank(),
        panel.grid.minor=element_blank(),
    panel.border=element_rect(colour="black", size=1, fill=NA),
    panel.background = element_rect(fill="white"))+
      xlab(paste0("PC1"," (",round(column_grabber(pcoa.asv,"values")[1,2]*100,2),"%)"))+
    ylab(paste0("PC2"," (",round(column_grabber(pcoa.asv,"values")[2,2]*100,2),"%)"))}
    }
  pcoa_func_out<-list(pcoa.asv,pcoa_plot)
  return(pcoa_func_out)
}

```

## Taxonomy String Cleaner

A function to clean-up taxonomy string names so that they are more aesthetically pleasing. Function takes as input the following object:

**taxonomy.table**: A taxonomy table object. 

```{r}
taxonomy_string_clean<-function(taxonomy.table){
    taxonomy.table[["Kingdom"]]<-sub("k__","",taxonomy.table[["Kingdom"]])
    taxonomy.table[["Phylum"]]<-sub("p__","",taxonomy.table[["Phylum"]])
    taxonomy.table[["Class"]]<-sub("c__","",taxonomy.table[["Class"]])
    taxonomy.table[["Order"]]<-sub("o__","",taxonomy.table[["Order"]])
    taxonomy.table[["Family"]]<-sub("f__","",taxonomy.table[["Family"]])
    taxonomy.table[["Genus"]]<-sub("g__","",taxonomy.table[["Genus"]])
    taxonomy.table[["Species"]]<-sub("s__","",taxonomy.table[["Species"]])
    taxonomy.table[is.na(taxonomy.table)]<-"Unassigned"
    return(taxonomy.table)
  }
```


## Relative Abundance Plot Function

A function to generates relative abundance bar charts that requires the following input:

1. **metadata**: The object containing metadata info to be used for grouping data. **ROW NAMES MUST MATCH THOSE IN ASV TABLE**
2. **taxonomy.table**: Taxonomy table generated by the dada2 pipeline
3. **asv.table**: Rarefied ASV table
4. **grouping.var**: Grouping variable present in the metadata object 
5. **taxon_level**: Taxonomy level to be used for plotting
6. **cut_off**: Relative abundance cut-off to be shown in the chart

```{r}

relative_abundance_plots<-function(metadata,taxonomy.table,asv.table,grouping.var,taxon_level,cut_off,kingdom){
if(deparse(substitute(taxon_level))=="Kingdom"){
  stop("YOU SPECIFIED TAXON LEVEL AS KINGDOM, THIS WILL BREAK THE CODE AND GIVE YOU A HEADACHE SO STOP")
}
  if(kingdom=="fungi"){
    taxonomy.table[["Kingdom"]]<-sub("k__","",taxonomy.table[["Kingdom"]])
    taxonomy.table[["Phylum"]]<-sub("p__","",taxonomy.table[["Phylum"]])
    taxonomy.table[["Class"]]<-sub("c__","",taxonomy.table[["Class"]])
    taxonomy.table[["Order"]]<-sub("o__","",taxonomy.table[["Order"]])
    taxonomy.table[["Family"]]<-sub("f__","",taxonomy.table[["Family"]])
    taxonomy.table[["Genus"]]<-sub("g__","",taxonomy.table[["Genus"]])
    taxonomy.table[["Species"]]<-sub("s__","",taxonomy.table[["Species"]])
     taxonomy.table[is.na(taxonomy.table)]<-"Unassigned"
  }
  metadata.asv.tab<-merge(metadata,asv.table,by.x=0,by.y=0) # Merges asv table and metadata file by row names
  metadata.asv.tab_group_sums<-metadata.asv.tab[,c(which(colnames(metadata.asv.tab)==paste0("",deparse(substitute(grouping.var)),"")),which(sapply(metadata.asv.tab,is.numeric)))]%>% # Takes the sum of each ASV by the grouping variable
    as.data.frame()%>%
    group_by({{grouping.var}})%>%
    summarize_all(sum)%>%
    as.data.frame()
  row.names(metadata.asv.tab_group_sums)<-metadata.asv.tab_group_sums[[deparse(substitute(grouping.var))]] # Converts grouping variable to rownames
  metadata.asv.tab_group_sums[[deparse(substitute(grouping.var))]]<-NULL # Removes duplicate column 
  t.metadata.asv.tab_group_sums<-as.data.frame(t(metadata.asv.tab_group_sums)) # Transposes group sum data frame
 t.metadata.asv.tab_group_sums[]<-as.data.frame(sapply(t.metadata.asv.tab_group_sums,as.numeric)) # Converts data to numeric
  metadata.asv.tab.taxonomy_group_sums<-merge(taxonomy.table,t.metadata.asv.tab_group_sums,by=0)
  # Merges taxonomy information into group summed ASV table
 metadata.asv.tab.taxonomy_taxon_sums<-metadata.asv.tab.taxonomy_group_sums[,c(which(colnames(metadata.asv.tab.taxonomy_group_sums)==paste0("",deparse(substitute(taxon_level)),"")),which(sapply(metadata.asv.tab.taxonomy_group_sums,is.numeric)))]%>% # Takes the sum of ASVs by their taxonomic assignment
 as.data.frame()%>%
group_by({{taxon_level}})%>%
summarize_all(sum)%>%
as.data.frame()

 metadata.asv.tab.taxonomy_taxon_sums[[deparse(substitute(taxon_level))]][which(is.na(metadata.asv.tab.taxonomy_taxon_sums[[deparse(substitute(taxon_level))]]))]<-"Unassigned" # Renames NA assignments as unassigned 
  rownames(metadata.asv.tab.taxonomy_taxon_sums)<-metadata.asv.tab.taxonomy_taxon_sums[[deparse(substitute(taxon_level))]] # Updates row names to taxonomy names
  metadata.asv.tab.taxonomy_taxon_sums[[deparse(substitute(taxon_level))]]<-NULL # Removes duplicate column
  t.metadata.asv.tab.taxonomy_taxon_sums<-as.data.frame(t(metadata.asv.tab.taxonomy_taxon_sums)) # Transposes data frame 
  t.metadata.asv.tab.taxonomy_taxon_cutoff<-t.metadata.asv.tab.taxonomy_taxon_sums[,which((colSums(t.metadata.asv.tab.taxonomy_taxon_sums[,grep("Unassigned",colnames(t.metadata.asv.tab.taxonomy_taxon_sums),invert=TRUE)])/sum(t.metadata.asv.tab.taxonomy_taxon_sums))>substitute(cut_off))] # Creates an object that has only those ASVs that have a relative abundance greater than the specified cut-off
    t.metadata.asv.tab.taxonomy_taxon_other<-t.metadata.asv.tab.taxonomy_taxon_sums[,which((colSums(t.metadata.asv.tab.taxonomy_taxon_sums[,grep("Unassigned",colnames(t.metadata.asv.tab.taxonomy_taxon_sums),invert=TRUE)])/sum(t.metadata.asv.tab.taxonomy_taxon_sums))<substitute(cut_off))] # Creates an object that contains only the taxa who fell below the specified relative abundance cut-off
  taxon_unassigned<-data.frame(Unassigned=t.metadata.asv.tab.taxonomy_taxon_sums[,grep("Unassigned",colnames(t.metadata.asv.tab.taxonomy_taxon_sums),invert=FALSE)]) # Creates an object to store the unassigned taxa
  other<-data.frame(Other=rowSums( t.metadata.asv.tab.taxonomy_taxon_other)) # Takes the sum of the taxa that fell below the cut-off
  t.metadata.asv.tab.taxonomy_taxon_cutoff_relabund<-decostand(cbind(t.metadata.asv.tab.taxonomy_taxon_cutoff,other,taxon_unassigned),method="total") # Calculates relative abundance 
  t.metadata.asv.tab.taxonomy_taxon_cutoff_relabund_long<-t.metadata.asv.tab.taxonomy_taxon_cutoff_relabund%>%
   tibble::rownames_to_column(var="Treatment")%>%
   pivot_longer(cols=!Treatment,names_to = "taxon_level_plot", values_to = "Relative.Abundance")%>%
    as.data.frame() # Converts data frame to long
  
t.metadata.asv.tab.taxonomy_taxon_cutoff_relabund_long[["taxon_level_plot"]]<-factor(unique(t.metadata.asv.tab.taxonomy_taxon_cutoff_relabund_long[["taxon_level_plot"]]),levels=unique(t.metadata.asv.tab.taxonomy_taxon_cutoff_relabund_long[["taxon_level_plot"]])) # Converts 

colour_count<-length(unique(t.metadata.asv.tab.taxonomy_taxon_cutoff_relabund_long[["taxon_level_plot"]]))
getPalette <- colorRampPalette(RColorBrewer::brewer.pal(9,"Set1"))
  
return(ggplot(t.metadata.asv.tab.taxonomy_taxon_cutoff_relabund_long,aes(x=Treatment,y=Relative.Abundance))+
geom_col(aes(x=Treatment,y=Relative.Abundance,fill=taxon_level_plot),linewidth=0.75,inherit.aes = FALSE,color="black")+
theme(panel.grid=element_blank(),panel.border = element_rect(color="black",fill=NA),panel.background = element_rect(fill="white"),legend.position = "bottom")+
  scale_fill_manual(values = c(getPalette(colour_count-1),"lightgrey"))+
guides(fill=guide_legend(title = deparse(substitute(taxon_level)))))
}

```

## Funguild Formatting Function

A function to generate funguild compatible OTU tables

1. **t_asv_taxonomy_table**: The imported ASV table that has ASV IDs as the rows and sample names as the columns. Should also have taxonomy columns from UNITE (Kingdom through Species). 

```{r}

funguild_formatting<-function(t_asv_taxonomy_table){
  colnames(t_asv_taxonomy_table)[1]<-"OTU ID" # Changes the name of the first column to OTU ID
  t_asv_taxonomy_table$taxonomy<-paste0(t_asv_taxonomy_table$Kingdom,";",t_asv_taxonomy_table$Phylum,";",t_asv_taxonomy_table$Class,";",t_asv_taxonomy_table$Order,";",t_asv_taxonomy_table$Family,";",t_asv_taxonomy_table$Genus,";",t_asv_taxonomy_table$Species) # Creates a column called taxonomy that contains the concatenated taxonomy strings
  t_asv_taxonomy_table_formatted<-subset(t_asv_taxonomy_table,select=-c(Kingdom,Phylum,Class,Order,Family,Genus,Species)) # drops the individual taxonomy columns for each taxonomic level. 
  print(colnames(t_asv_taxonomy_table_formatted))
  return(t_asv_taxonomy_table_formatted)
}

```

# Data Importing

Importing the following files to be used for analyses: 

1. **feb_22_2024.t.seqtab.tax_its_phloem_manuscript_version**: final version of the ASV table that includes taxonomy assignments and count data for each ASV. 
2. **metadata.2020.nursery.study_microbiome_transcriptome**: metadata file that describes the treatments applied to each tree. 

```{r}
# Importing study metadata
metadata_phloem<-read.table("~/Google Drive/My Drive/utk_project/phospho_jet_rootshield_manuscript/manuscript_versions/manuscript_v01/raw_data/metadata.2020.nursery.study_microbiome_transcriptome.txt",header=TRUE,sep='\t')

# Importing canker areas
canker.dat<-read.table("~/Google Drive/My Drive/utk_project/phospho_jet_rootshield_manuscript/manuscript_versions/manuscript_v01/canker_data_jnigrarnaseq_summer20_ajo/cankers_rnaseq_2_ajo_su20.txt",sep="\t",na.strings="NA",header=TRUE)

# Importing transposed ASV table with taxonomy information into R. 
t.seqtab.tax_its_phloem_original<-read.table("~/Google Drive/My Drive/utk_project/phospho_jet_rootshield_manuscript/manuscript_versions/manuscript_v01/analyses/r_sequence_processing_data/feb_22_2024.t.seqtab.tax_its_phloem_manuscript_version.txt",header=TRUE,sep='\t')

# Importing transposed ASV table with taxonomy information into R. 
t.seqtab.tax_16s_phloem_original<-read.table("~/Google Drive/My Drive/utk_project/phospho_jet_rootshield_manuscript/manuscript_versions/manuscript_v01/analyses/r_sequence_processing_data/feb_22_2024.t.seqtab.tax_16s_phloem_manuscript_version.txt",header=TRUE,sep='\t')

# Importing ASVs identified as Geosmithia morbida
geosmithia_labels<-labels(read.FASTA("~/Google Drive/My Drive/utk_project/phospho_jet_rootshield_manuscript/manuscript_versions/manuscript_v01/analyses/r_sequence_processing_data/geosmithia.asvs.fa"))

```

# Data Formatting

## Formatting Canker Area Data

```{r}
# Removing NA values
canker.dat.naomit<-na.omit(canker.dat)

# Converting day to a factor
canker.dat.naomit$Day<-as.factor(canker.dat.naomit$Day)
```

## Formatting Data for Funguild Import

```{r}
# Formatting asv table with taxonomy information for use with funguild. 
funguild_import_phloem<-funguild_formatting(t.seqtab.tax_its_phloem_original)

# Exporting funguild formatted table
#write.table(funguild_import_phloem,"~/Google Drive/My Drive/utk_project/phospho_jet_rootshield_manuscript/manuscript_versions/manuscript_v01/analyses/r_sequence_processing_data/funguild.import_j.nigra_nursery_study.txt",col.names = TRUE,row.names = FALSE,sep='\t',quote = FALSE)

# Importing funguild assignments. 
funguild_results_phloem<-read.table("~/Google Drive/My Drive/utk_project/phospho_jet_rootshield_manuscript/manuscript_versions/manuscript_v01/analyses/r_sequence_processing_data/funguild.import_j.nigra_nursery_study.guilds.txt",header=TRUE,sep='\t')

# Subsetting Funguild results to include only relevant information. 
funguild_results_phloem_guild<-subset(funguild_results_phloem,select=c("OTU.ID","Taxon","Guild"))

funguild_import_phloem_v2<-funguild_import_phloem

funguild_import_phloem_v2$asv_labels<-row.names(funguild_import_phloem_v2)

funguild_import_phloem_v2<-funguild_import_phloem_v2[,c(1,length(funguild_import_phloem_v2))]

funguild_results_phloem_guild_formatted<-merge(funguild_import_phloem_v2,funguild_results_phloem_guild,by.x="OTU ID",by.y="OTU.ID")

funguild_results_phloem_guild_formatted$asv_labels<-sub(" ",".",funguild_results_phloem_guild_formatted$asv_labels)
```

## Metadata Formatting

Reformatting the **metadata_phloem** object.  **t.seqtab.tax_its_phloem_original** object so that there are separate taxonomy and ASV tables. 

```{r}
# Making row names the sample ID in the metadata
row.names(metadata_phloem)<-metadata_phloem$Tree.ID

# Reformatting names of some treatments in metadata file
metadata_phloem$Treatment<-sub("Phospho-Jet","PA",metadata_phloem$Treatment)
metadata_phloem$Treatment<-sub("Rootshield","KRL-AG2",metadata_phloem$Treatment)
metadata_phloem$Treatment<-sub("Control","WC",metadata_phloem$Treatment)

metadata_phloem$GM<-sub("GM17","TN Gm17",metadata_phloem$GM)

metadata_phloem$Day<-paste0("D",metadata_phloem$Day)

# Creating addition columns for potential treatment combinations of interest

# Inoculation Type x Management Treatment
metadata_phloem$GMTrT<-paste0(metadata_phloem$GM,"_",metadata_phloem$Treatment)

# Date x Inoculation Type x Management Treatment
metadata_phloem$DayGMTrT<-paste0(metadata_phloem$Day,"_",metadata_phloem$GM,"_",metadata_phloem$Treatment)

# Date x Management Treatment
metadata_phloem$DayTrT<-paste0(metadata_phloem$Day,"_",metadata_phloem$Treatment)

# Date x Inoculation Type
metadata_phloem$DayGM<-paste0(metadata_phloem$Day,"_",metadata_phloem$GM)
```

## Fungal ASV Table Formatting

Reformatting the **t.seqtab.tax_its_phloem_original** object so that there are separate taxonomy and ASV tables. 

```{r}
# Selecting only the ASV count data
t.asv.tab_its_phloem<-select_if(t.seqtab.tax_its_phloem_original,is.numeric)

# Transposing the ASV table so that it can be used with vegan
asv.tab_its_phloem<-t(t.asv.tab_its_phloem)

# Adjusting names to remove space and have a period
colnames(asv.tab_its_phloem)<-sub(" ",".",colnames(asv.tab_its_phloem))

# Merging metadata and ASV table together
metadata.asv.tab_its_phloem<-merge(metadata_phloem,asv.tab_its_phloem,by.x="Tree.ID",by.y=0)

# Checking that row names and column names are as expected. Row names should be sample names and column names should be ASV labels. 
rownames(asv.tab_its_phloem)
colnames(asv.tab_its_phloem)

# Selecting only the taxonomy data
asv.tax_its_phloem<-select_if(t.seqtab.tax_its_phloem_original[,-1],is.character)

# Cleaning taxonomy strings
asv.tax_its_phloem_clean<-taxonomy_string_clean(asv.tax_its_phloem)

# Adjusting row names to remove space and include a period. 
row.names(asv.tax_its_phloem_clean)<-sub(" ",".",row.names(asv.tax_its_phloem_clean))

geosmithia_labels<-sub(" ",".",geosmithia_labels)

```

## Bacterial/Archaeal ASV Table Formatting

Reformatting the **t.seqtab.tax_16s_phloem_original** object so that there are separate taxonomy and ASV tables. 

```{r}
# Selecting only the ASV count data
t.asv.tab_16s_phloem<-select_if(t.seqtab.tax_16s_phloem_original,is.numeric)

# Transposing the ASV table so that it can be used with vegan
asv.tab_16s_phloem<-t(t.asv.tab_16s_phloem)

# Adjusting names to remove space and have a period
colnames(asv.tab_16s_phloem)<-sub(" ",".",colnames(asv.tab_16s_phloem))

# Merging metadata and ASV table together
metadata.asv.tab_16s_phloem<-merge(metadata_phloem,asv.tab_16s_phloem,by.x="Tree.ID",by.y=0)

# Checking that row names and column names are as expected. Row names should be sample names and column names should be ASV labels. 
rownames(asv.tab_16s_phloem)
colnames(asv.tab_16s_phloem)

# Selecting only the taxonomy data
asv.tax_16s_phloem<-select_if(t.seqtab.tax_16s_phloem_original[,-1],is.character)

# Cleaning taxonomy strings
asv.tax_16s_phloem_clean<-taxonomy_string_clean(asv.tax_16s_phloem)

```

# Canker Analysis

Using linear mixed effects models to test for significant effects of management treatments on canker sizes. 

Fixed effects include:

Additive
1. **Treatment**: Management treatment 
2. **Inoculum**: *G. morbida* or 1/2 PDA
3. **Day**: Number of days post-treatment application

Interactive
4. **Day x Inoculum**: Sampling Date and Inoculation type to see if cankers differ in size between days. 
5. **Treatment x Inoculum**: Treatment and Inoculation type to see if cankers differ in size between treatments based on inoculation type
6. **Treatment x Inoculum x Day**: Treatment and Inoculation type to see if cankers differ in size between treatments based on inoculation type and sampling date.

```{r}
# Using the lme function to test for significant effects of management treatments on canker sizes.
canker.mixed.lme<-lme(Area~Treatment+Inoculum+Day*Inoculum+Treatment*Inoculum+Treatment*Inoculum*Day,random=~1|Tree.ID, data=canker.dat.naomit)

# Check assumptions
plot(canker.mixed.lme)
qqnorm(resid(canker.mixed.lme))
qqline(resid(canker.mixed.lme))

# Log transforming data to better meet model assumptions
canker.mixed.lme.log<-lme(log(Area)~Treatment+Inoculum+Day*Inoculum+Treatment*Inoculum+Treatment*Inoculum*Day,random=~1|Tree.ID, data=canker.dat.naomit)

# Check assumptions
plot(canker.mixed.lme.log)
qqnorm(resid(canker.mixed.lme.log))
qqline(resid(canker.mixed.lme.log))

# Calculate P-values
canker.mixed.anova<-anova(canker.mixed.lme.log)
canker.mixed.anova
lme_p_values<-emmeans(canker.mixed.lme,list(pairwise ~ Day*Inoculum), adjust="Tukey")

# Summarizing results
lme_p_values_df<-as.data.frame(lme_p_values$`pairwise differences of Day, Inoculum`)

# Looking at comparsions of Day 14 inoculum types
lme_p_values_df[grep("Day14 PDA - Day14 TN Gm17",lme_p_values_df$`1`),]

# Looking at comparisons of Day 28 inoculum types
lme_p_values_df[grep("Day28 PDA - Day28 TN Gm17",lme_p_values_df$`1`),]

# Looking at comparisons of Day 56 inoculum types
lme_p_values_df[grep("Day56 PDA - Day56 TN Gm17",lme_p_values_df$`1`),]

# Plotting results in ggplot
Day<-c(14,28,56,14,28,56)
sig_diffs<-c(NA,"B","A",NA,"A","B")
x_labs<-c("PDA","TN Gm17","PDA","TN Gm17","PDA","TN Gm17")
x_seg_01<-c(NA,0.55,0.55,NA,0.55,0.55)
x_end_seg_01<-c(NA,1.5,1.5,NA,1.5,1.5)
x_seg_02<-c(NA,1.55,1.55,NA,1.55,1.55)
x_end_seg_02<-c(NA,2.5,2.5,NA,2.5,2.5)

label_data<-as.data.frame(cbind(Day,x_labs,sig_diffs,x_seg_01,x_end_seg_01,x_seg_02,x_end_seg_02))
label_data[,4]<-as.numeric(label_data[,4])
label_data[,5]<-as.numeric(label_data[,5])
label_data[,6]<-as.numeric(label_data[,6])
label_data[,7]<-as.numeric(label_data[,7])

canker_analysis<-ggplot(canker.dat.naomit,aes(x=Inoculum,y=Area,colour=Treatment))+
  geom_boxplot(position=position_dodge(1),outlier.shape=NA,aes(fill=Treatment),alpha=0.3)+
  geom_jitter(aes(fill=Treatment),position=position_jitterdodge(jitter.width=0.2,dodge.width=1),size=1)+
  xlab("Inoculum Type")+
  ylab(expression(Area~(cm^2)))+
  facet_grid(.~Day)+
  geom_segment(data=label_data,aes(x = x_seg_01,xend=x_end_seg_01,y=3.7,yend=3.7),inherit.aes = FALSE)+
  geom_segment(data=label_data,aes(x = x_seg_02,xend=x_end_seg_02,y=3.7,yend=3.7),inherit.aes = FALSE)+
  geom_text(data=label_data,aes(x=x_labs,y=3.8,label=sig_diffs),inherit.aes = FALSE)+
  guides(fill=guide_legend("Management Treatment"),color=guide_legend("Management Treatment"))+
  theme(panel.grid=element_blank(),panel.border = element_rect(color="black",fill=NA),panel.background=element_blank(),axis.ticks.x = element_blank(),axis.line.y.left = element_line(color="black"),axis.line.x.bottom = element_line(color="black"))+
  scale_fill_discrete(labels=c("WC","PA","KRL-AG2"))+
  scale_color_discrete(labels=c("WC","PA","KRL-AG2"))

canker_analysis

```



# Sample Rarefaction

Prior to performing alpha- and beta-diversity analyses, rarefying samples to the same sequencing depth. Rarefying data is the recommended data normalization technique for amplicon sequencing studies [Schloss et al. 2024](https://journals.asm.org/doi/full/10.1128/msphere.00354-23).

## Fungal Rarefaction

Rarefying fungal community data. 

```{r}
# Determining the number of sequences per sample starting from least to greatest. 
sort(rowSums(asv.tab_its_phloem))

# Using the rarecurve function from vegan to generate rarefaction curves
asv.rarecurve.tab_its_phloem<-vegan::rarecurve(asv.tab_its_phloem,tidy = TRUE)

# Plotting rarefaction curves in ggplot
rarecurve.plot_its<-ggplot()+
  geom_line(data=asv.rarecurve.tab_its_phloem,aes(x=Sample,y=Species,color=Site))+
  geom_vline(data=NULL,xintercept=c(sort(rowSums(asv.tab_its_phloem))[2]),color="black",linetype=2)+
   theme(panel.background = element_blank(),legend.position="none",panel.border = element_rect(fill=NA,color="black"))+
  xlab("Number of Sequences")+
  ylab("ASV Count")

rarecurve.plot_its

# Using the custom rarefy_formatting function to rarefy all samples to the same sequencing depth. 
#rare.asv.tab_its_phloem<-rarefy_formatting(asv.tab_its_phloem,sample=sort(rowSums(asv.tab_its_phloem))[2])

# Writing the rarefied ASV table to file. 
#write.table(rare.asv.tab_its_phloem,"~/Google Drive/My Drive/utk_project/phospho_jet_rootshield_manuscript/manuscript_versions/manuscript_v01/analyses/r_sequence_processing_data/feb_23_2024_its_rarefied_asv_table_manuscript_version.txt",row.names=TRUE,col.names=TRUE,sep='\t')

```

## Bacterial/Archaeal Rarefaction

Rarefying Bacterial/Archaeal community data.

```{r}
# Determining the number of sequences per sample starting from least to greatest. 
sort(rowSums(asv.tab_16s_phloem))

# Using the rarecurve function from vegan to generate rarefaction curves
asv.rarecurve.tab_16s_phloem<-vegan::rarecurve(asv.tab_16s_phloem,tidy = TRUE)

# Plotting rarefaction curves in ggplot
rarecurve.plot_16s<-ggplot()+
  geom_line(data=asv.rarecurve.tab_16s_phloem,aes(x=Sample,y=Species,color=Site))+
  geom_vline(data=NULL,xintercept=c(sort(rowSums(asv.tab_16s_phloem))[6]),color="black",linetype=2)+
  theme(panel.background = element_blank(),legend.position="none",panel.border = element_rect(fill=NA,color="black"))+
  xlab("Number of Sequences")+
  ylab("ASV Count")

rarecurve.plot_16s

# Using the custom rarefy_formatting function to rarefy all samples to the same sequencing depth. 
#rare.asv.tab_16s_phloem<-rarefy_formatting(asv.tab_16s_phloem,sample=sort(rowSums(asv.tab_16s_phloem))[6])

# Writing the rarefied ASV table to file. 
#write.table(rare.asv.tab_16s_phloem,"~/Google Drive/My Drive/utk_project/phospho_jet_rootshield_manuscript/manuscript_versions/manuscript_v01/analyses/r_sequence_processing_data/feb_23_2024_16s_rarefied_asv_table_manuscript_version.txt",row.names=TRUE,col.names=TRUE,sep='\t')

```

## Creating Rarefaction Panel Figure

```{r}

ggarrange(rarecurve.plot_its,rarecurve.plot_16s,nrow=2,labels = c("a","b"))

```

# Alpha-Diversity Analyses

Testing for differences in alpha-diversity or the richness and diversity of taxa between treatments.

## Fungal Alpha-Diversity Analyses

Testing for differences in alpha-diversity or the richness and diversity of fungal taxa between treatments.

```{r}
# Reading in the rarefied ASV table 
rare.asv.tab_its_phloem<-read.table("~/Google Drive/My Drive/utk_project/phospho_jet_rootshield_manuscript/manuscript_versions/manuscript_v01/analyses/r_sequence_processing_data/feb_23_2024_its_rarefied_asv_table_manuscript_version.txt",header=TRUE,sep='\t')

# Merging the sample metadata with the rarefied asv table
metadata.rare.asv.tab_its_phloem<-merge(metadata_phloem,rare.asv.tab_its_phloem,by.x="Tree.ID",by.y=0)

# Calculating alpha-diversity measures usuing the hillR function.
its.phloem_alpha_diversity<-data.frame(select_if(metadata.rare.asv.tab_its_phloem,is.character),q0=hill_taxa(select_if(metadata.rare.asv.tab_its_phloem,is.numeric),q=0),q1=hill_taxa(select_if(metadata.rare.asv.tab_its_phloem,is.numeric),q=1),q2=hill_taxa(select_if(metadata.rare.asv.tab_its_phloem,is.numeric),q=2))

# Performing ANOVA for q0 with interaction term first
its.phloem_q0<-aov(formula=q0~Day*Treatment*GM,its.phloem_alpha_diversity)
par(mfrow=c(2,2))
plot(its.phloem_q0)
car::Anova(its.phloem_q0,type="III")

# Performing ANOVA for q0 with non-significant interaction terms dropped
its.phloem_q0<-aov(formula=q0~Day+Treatment+GM,its.phloem_alpha_diversity)
par(mfrow=c(2,2))
plot(its.phloem_q0)
car::Anova(its.phloem_q0,type="III")

# Performing ANOVA for q1 with interaction term first
its.phloem_q1<-aov(formula=q1~Day*Treatment*GM,its.phloem_alpha_diversity)
par(mfrow=c(2,2))
plot(its.phloem_q1)
car::Anova(its.phloem_q1,type="III")

# Performing ANOVA for q1 with non-significant interaction terms dropped
its.phloem_q1<-aov(formula=q1~Day+Treatment+GM,its.phloem_alpha_diversity)
par(mfrow=c(2,2))
plot(its.phloem_q1)
car::Anova(its.phloem_q1,type="III")

# Performing ANOVA for q2 with interaction term first
its.phloem_q2<-aov(formula=q2~Day*Treatment*GM,its.phloem_alpha_diversity)
par(mfrow=c(2,2))
plot(its.phloem_q2)
car::Anova(its.phloem_q2,type="III")

# Performing ANOVA for q2 with non-significant interaction terms dropped
its.phloem_q2<-aov(formula=q2~Day+Treatment+GM,its.phloem_alpha_diversity)
par(mfrow=c(2,2))
plot(its.phloem_q2)
car::Anova(its.phloem_q2,type="III")


# Converting to long form
its.phloem_alpha_diversity_long<-gather(its.phloem_alpha_diversity,key="q",value="index",11:13)


# Plotting alpha-diversity in ggplot
fungal_alpha_diversity<-ggplot(its.phloem_alpha_diversity_long,aes(x=Treatment,y=index,fill=GMTrT))+
 geom_boxplot(position=position_dodge(0.8),outlier.shape = NA)+
  geom_jitter(position=position_dodge(0.8),aes(fill=GMTrT),shape=21,alpha=0.5,color="black")+
  facet_wrap(.~q,scales = "free_y",dir = "v")+
  guides(fill=guide_legend("Management Treatment"))+
  theme(panel.grid=element_blank(),panel.border = element_blank(),panel.background=element_blank(),axis.ticks.x = element_blank(),axis.line.y.left = element_line(color="black"),axis.line.x.bottom = element_line(color="black"))+
  ylab("Index Value")+
  xlab("Management Treatment")
  #scale_fill_discrete(labels=c("PDA x PHOSPHO-JET","PDA x RootShield", "PDA x Water Control", "TN Gm17 x PHOSPHO-JET","TN GM17 x RootShield","TN GM17 x Water Control"))

fungal_alpha_diversity
```

## Archaeal/Bacterial Alpha-Diversity Analyses

Testing for differences in alpha-diversity or the richness and diversity of archaeal/bacterial taxa between treatments.

```{r}
# Reading in the rarefied ASV table 
rare.asv.tab_v4_phloem<-read.table("~/Google Drive/My Drive/utk_project/phospho_jet_rootshield_manuscript/manuscript_versions/manuscript_v01/analyses/r_sequence_processing_data/feb_23_2024_16s_rarefied_asv_table_manuscript_version.txt",header=TRUE,sep='\t')

# Merging the sample metadata with the rarefied asv table
metadata.rare.asv.tab_v4_phloem<-merge(metadata_phloem,rare.asv.tab_v4_phloem,by.x="Tree.ID",by.y=0)

# Calculating alpha-diversity measures usuing the hillR function.
v4.phloem_alpha_diversity<-data.frame(select_if(metadata.rare.asv.tab_v4_phloem,is.character),q0=hill_taxa(select_if(metadata.rare.asv.tab_v4_phloem,is.numeric),q=0),q1=hill_taxa(select_if(metadata.rare.asv.tab_v4_phloem,is.numeric),q=1),q2=hill_taxa(select_if(metadata.rare.asv.tab_v4_phloem,is.numeric),q=2))

# Performing ANOVA for q0 with interaction term first
v4.phloem_q0<-aov(formula=q0~Day*Treatment*GM,v4.phloem_alpha_diversity)
par(mfrow=c(2,2))
plot(v4.phloem_q0)
car::Anova(v4.phloem_q0,type="III")

# Performing ANOVA for q0 with non-significant interaction terms dropped
v4.phloem_q0<-aov(formula=q0~Day+Treatment+GM,v4.phloem_alpha_diversity)
par(mfrow=c(2,2))
plot(v4.phloem_q0)
car::Anova(v4.phloem_q0,type="III")
TukeyHSD(v4.phloem_q0)

# Performing ANOVA for q1 with interaction term first
v4.phloem_q1<-aov(formula=q1~Day*Treatment*GM,v4.phloem_alpha_diversity)
par(mfrow=c(2,2))
plot(v4.phloem_q1)
car::Anova(v4.phloem_q1,type="III")

# Performing ANOVA for q1 with non-significant interaction terms dropped
v4.phloem_q1<-aov(formula=q1~Day+Treatment+GM,v4.phloem_alpha_diversity)
par(mfrow=c(2,2))
plot(v4.phloem_q1)
car::Anova(v4.phloem_q1,type="III")
TukeyHSD(v4.phloem_q1)

# Performing ANOVA for q2 with interaction term first
v4.phloem_q2<-aov(formula=q2~Day*Treatment*GM,v4.phloem_alpha_diversity)
par(mfrow=c(2,2))
plot(v4.phloem_q2)
car::Anova(v4.phloem_q2,type="III")

# Performing ANOVA for q2 with non-significant interaction terms dropped
v4.phloem_q2<-aov(formula=q2~Day+Treatment+GM,v4.phloem_alpha_diversity)
par(mfrow=c(2,2))
plot(v4.phloem_q2)
car::Anova(v4.phloem_q2,type="III")
TukeyHSD(v4.phloem_q2)

# Converting to long form
v4.phloem_alpha_diversity_long<-gather(v4.phloem_alpha_diversity,key="q",value="index",11:13)

alpha_index_labels<-data.frame(Treatment=c("KRL-AG2","PA","WC","KRL-AG2","PA","WC","KRL-AG2","PA","WC"),label=c("A","B","AB",NA,NA,NA,NA,NA,NA),q=c("q0","q0","q0","q1","q1","q1","q2","q2","q2"),y=c(800,800,800,NA,NA,NA,NA,NA,NA),xstart=c(0.6,1.6,2.6,NA,NA,NA,NA,NA,NA),xend=c(1.4,2.4,3.4,NA,NA,NA,NA,NA,NA))

# Plotting alpha-diversity in ggplot
bacteria_alpha_diversity<-ggplot(v4.phloem_alpha_diversity_long,aes(x=Treatment,y=index,fill=GMTrT))+
 geom_boxplot(position=position_dodge(0.8),outlier.shape = NA)+
  geom_jitter(position=position_dodge(0.8),aes(fill=GMTrT),shape=21,alpha=0.5,color="black")+
 geom_text(data=alpha_index_labels,aes(x=Treatment,y=y+50,label=label),inherit.aes = FALSE)+
  geom_segment(data=alpha_index_labels,aes(x=xstart,xend=xend,y=y,yend=y),inherit.aes = FALSE)+
  facet_wrap(.~q,scales = "free_y",dir = "v")+
  guides(fill=guide_legend("Management Treatment"))+
  theme(panel.grid=element_blank(),panel.border = element_blank(),panel.background=element_blank(),axis.ticks.x = element_blank(),axis.line.y.left = element_line(color="black"),axis.line.x.bottom = element_line(color="black"))+
  ylab("Index Value")+
  xlab("Management Treatment")

bacteria_alpha_diversity
```

## Creating Alpha-Diversity Panel

```{r}

ggarrange(fungal_alpha_diversity,bacteria_alpha_diversity,labels=c("a","b"),nrow=1,common.legend = TRUE)

```

# Beta-Diversity Analyses

Comparing differences in community composition between samples using principal coordinate analyses. 

```{r}
# Reading in the rarefied ASV table 
rare.asv.tab_its_phloem<-read.table("~/Google Drive/My Drive/utk_project/phospho_jet_rootshield_manuscript/manuscript_versions/manuscript_v01/analyses/r_sequence_processing_data/feb_23_2024_its_rarefied_asv_table_manuscript_version.txt",header=TRUE,sep='\t')

# Merging the sample metadata with the rarefied asv table
metadata.rare.asv.tab_its_phloem<-merge(metadata_phloem,rare.asv.tab_its_phloem,by.x="Tree.ID",by.y=0)

# Generating PCoA and ordination plot
pcoa_all_dates_its_phloem<-pcoa_imager(table = metadata.rare.asv.tab_its_phloem,method = "bray",point_ellipse_color = "GM",shape = "Treatment",polygon = TRUE,ellipse_fill = "Treatment")
pcoa_all_dates_its_phloem_plot<-pcoa_all_dates_its_phloem[2][[1]]+
 # scale_fill_discrete(labels=c("PDA","TN Gm17"))+
#  scale_color_discrete(labels=c("PDA x PHOSPHO-JET","PDA x RootShield", "PDA x Water Control", "TN Gm17 x PHOSPHO-JET","TN GM17 x RootShield","TN GM17 x Water Control"))+
 # scale_shape_discrete(labels=c("PDA","TN Gm17"))+
  guides(fill=guide_legend("Management Treatment"),shape=guide_legend("Management Treatment"), color=guide_legend("Inoculum"))+
  theme(legend.position = "top")
pcoa_all_dates_its_phloem_plot

# Conducting PERMANOVA
permanova_all_dates_its_phloem<-as_tibble(adonis2(select_if(metadata.rare.asv.tab_its_phloem,is.numeric)~metadata.rare.asv.tab_its_phloem$Treatment*metadata.rare.asv.tab_its_phloem$GM*metadata.rare.asv.tab_its_phloem$Day,method = "bray",permutations = 9999),rownames = "Variable")

# Formatting table so it is easier to read
permanova_all_dates_its_phloem$Variable<-gsub("metadata.rare.asv.tab_its_phloem\\$","",permanova_all_dates_its_phloem$Variable)

# Generating summary
permanova_all_dates_its_phloem

# Creating a new ASV table object that is the same as above just a separate object from which we will remove the G
#metadata.rare.asv.tab_its_phloem_relabund<-metadata.rare.asv.tab_its_phloem

# Subsetting the ASV table to retain only those there were identified as G. morbida
metadata.rare.asv.tab_its_phloem_gm<-metadata.rare.asv.tab_its_phloem[,c(which(sapply(metadata.asv.tab_its_phloem,is.character)),which(colnames(metadata.rare.asv.tab_its_phloem)%in%geosmithia_labels))]

# Taking the sums of all Geosmithia ASVs within a given sample
metadata.rare.asv.tab_its_phloem_gm_sums<-as.data.frame(metadata.rare.asv.tab_its_phloem_gm)%>%
  dplyr::mutate(gmsum=rowSums(across(where(is.numeric))))

# Subsetting so that only smple metadata and Geosmithia sums are retained
metadata.rare.asv.tab_its_phloem_gm_sums<-metadata.rare.asv.tab_its_phloem_gm_sums[,c(which(sapply(metadata.asv.tab_its_phloem,is.character)),length(metadata.rare.asv.tab_its_phloem_gm_sums))]

# Creating a column that contains the total number of sequences per samples (should be the rarefaction cut-off)
metadata.rare.asv.tab_its_phloem_gm_sums$total_seqs<-rowSums(rare.asv.tab_its_phloem)

# Computing relative abundance of Geosmithia ASVs per sample
metadata.rare.asv.tab_its_phloem_gm_sums$relative_abundance<-metadata.rare.asv.tab_its_phloem_gm_sums$gmsum/metadata.rare.asv.tab_its_phloem_gm_sums$total_seqs

# Calculating mean and standard deviation of Geosmithia ASVs for treatments
metadata.rare.asv.tab_its_phloem_relabund_gm_long_avg<-as.data.frame(metadata.rare.asv.tab_its_phloem_gm_sums)%>%
  group_by(GMTrT)%>%
  dplyr::summarise(Mean=mean(relative_abundance),SD=sd(relative_abundance))

metadata.rare.asv.tab_its_phloem_relabund_gm_long_avg

# Plotting results in ggplot
gmorbida_relabund<-ggplot(metadata.rare.asv.tab_its_phloem_gm_sums,aes(x=Treatment,y=relative_abundance,fill=GMTrT))+
  geom_boxplot(position=position_dodge(0.8),outlier.shape = NA)+
  geom_jitter(position=position_dodge(0.8),aes(fill=GMTrT),shape=21,alpha=0.5,color="black")+
  guides(fill=guide_legend("Inoculum x Management Treatment"))+
  theme(panel.grid=element_blank(),panel.border = element_rect(color="black",fill=NA,linewidth = 1),panel.background=element_blank(),axis.ticks.x = element_blank(),legend.position="top")+
  ylab("Relative Abundance")+
  xlab("Management Treatment")+
    theme(axis.title.x=element_text(size=14, face="bold"))+
  theme(axis.title.y=element_text(size=14, face="bold"))+
  theme(axis.text.x=element_text(size=12, face="bold"))+
  theme(axis.text.y=element_text(size=12, face="bold"))
 gmorbida_relabund
 
 # Generating PCoA and ordination plot for fungal communities but with G. morbida removed
pcoa_all_dates_its_phloem_no_gm<-pcoa_imager(table = metadata.rare.asv.tab_its_phloem[,!colnames(metadata.rare.asv.tab_its_phloem)%in%geosmithia_labels],method = "bray",point_ellipse_color = "GM",shape = "Treatment",polygon = TRUE,ellipse_fill = "Treatment")

# Plotting G. morbida removed fungal communities in ggplot
pcoa_all_dates_its_phloem_no_gm_plot<-pcoa_all_dates_its_phloem_no_gm[2][[1]]+
 # scale_shape_discrete(labels=c("PDA","TN Gm17"))+
  guides(fill=guide_legend("Management Treatment"),shape=guide_legend("Management Treatment"), color=guide_legend("Inoculum"))+
  theme(legend.position = "top")
pcoa_all_dates_its_phloem_no_gm_plot


# Conducting PERMANOVA on G. morbida removed fungal communities
core_permanova_all_dates_its_phloem<-as_tibble(adonis2(select_if(metadata.rare.asv.tab_its_phloem[,!colnames(metadata.rare.asv.tab_its_phloem)%in%geosmithia_labels],is.numeric)~metadata.rare.asv.tab_its_phloem[,!colnames(metadata.rare.asv.tab_its_phloem)%in%geosmithia_labels]$Treatment*metadata.rare.asv.tab_its_phloem[,!colnames(metadata.rare.asv.tab_its_phloem)%in%geosmithia_labels]$GM*metadata.rare.asv.tab_its_phloem[,!colnames(metadata.rare.asv.tab_its_phloem)%in%geosmithia_labels]$Day, method = "bray",permutations = 9999),rownames = "Variable")

core_permanova_all_dates_its_phloem
```


# Funguild Analyses

```{r}
# Reading in the rarefied ASV table 
rare.asv.tab_its_phloem<-read.table("~/Google Drive/My Drive/utk_project/phospho_jet_rootshield_manuscript/manuscript_versions/manuscript_v01/analyses/r_sequence_processing_data/feb_23_2024_its_rarefied_asv_table_manuscript_version.txt",header=TRUE,sep='\t')

# Merging funguild results with rarefied ASV table
funguild.rare.asv<-merge(funguild_results_phloem_guild_formatted,as.data.frame(t(rare.asv.tab_its_phloem)),by.x="asv_labels",by.y=0)

# Converting row names to ASV labels
row.names(funguild.rare.asv)<-funguild.rare.asv$asv_labels

# Weighting ASV counts by the number of guilds assigned to each ASV
funguild.rare.asv.div<-merge(funguild.rare.asv[,1:4],funguild.rare.asv[,5:75]/(str_count(funguild.rare.asv$Guild,pattern="-")+1),by.x=0,by.y=0)

# Splitting the functional guild names by dash and creating duplicate columns. 
funguild.rare.asv.div.sep<-as.data.frame(separate_rows(funguild.rare.asv.div, Guild, sep="-"))

# Using grep to pull out only ASVs identified as putative plant pathogens
funguild_plantpathogen_rare.asv<-funguild.rare.asv.div.sep[grep("Plant Pathogen",funguild.rare.asv.div.sep$Guild),]

# Converting row names to ASV labels
row.names(funguild_plantpathogen_rare.asv)<-funguild_plantpathogen_rare.asv$asv_labels

# Pulling out the ASV table
funguild_plantpathogen_rare.asv_fmt<-select_if(funguild_plantpathogen_rare.asv,is.numeric)

# Adding sample metadata to the ASV table
metadata_funguild_plantpathogen_rare.asv_fmt<-as.data.frame(merge(metadata_phloem,as.data.frame(t(funguild_plantpathogen_rare.asv_fmt)),by.x=0,by.y=0))

# Generating PCoA and ordination plot for fungal plant pathogens without G. morbida
pcoa_all_dates_its_phloem_no_gm_plantpathogen<-pcoa_imager(table = metadata_funguild_plantpathogen_rare.asv_fmt[,!colnames(metadata_funguild_plantpathogen_rare.asv_fmt)%in%geosmithia_labels],method = "bray",point_ellipse_color = "GM",shape = "Treatment",polygon = TRUE,ellipse_fill = "Treatment")

# Plotting G. morbida removed fungal communities in ggplot
pcoa_all_dates_its_phloem_no_gm_plantpathogen_plot<-pcoa_all_dates_its_phloem_no_gm_plantpathogen[2][[1]]+
 # scale_shape_discrete(labels=c("PDA","TN Gm17"))+
  guides(fill=guide_legend("Management Treatment"),shape=guide_legend("Management Treatment"), color=guide_legend("Inoculum"))+
  theme(legend.position = "top")+
  geom_text(data=NULL,inherit.aes=FALSE,aes(x=-0.15,y=0.4,label="Plant Pathogens"))
pcoa_all_dates_its_phloem_no_gm_plantpathogen_plot

# Creating a plant pathogen funguild objet that has G. morbida ASVs removed for simplicity
metadata_funguild_plantpathogen_rare.asv_fmt_no_gm<-metadata_funguild_plantpathogen_rare.asv_fmt[,!colnames(metadata_funguild_plantpathogen_rare.asv_fmt)%in%geosmithia_labels]

# Conducting PERMANOVA on plant pathogen communities with G. morbida removed fungal communities
plantpathogen_permanova_its_phloem<-as_tibble(adonis2(select_if(metadata_funguild_plantpathogen_rare.asv_fmt_no_gm,is.numeric)~metadata_funguild_plantpathogen_rare.asv_fmt_no_gm$Treatment*metadata_funguild_plantpathogen_rare.asv_fmt_no_gm$GM*metadata_funguild_plantpathogen_rare.asv_fmt_no_gm$Day, method = "bray",permutations = 9999),rownames = "Variable")

plantpathogen_permanova_its_phloem

# Using grep to pull out only ASVs identified as putative fungal parasite
funguild_mycoparasite_rare.asv<-funguild.rare.asv.div.sep[grep("Fungal Parasite",funguild.rare.asv.div.sep$Guild),]

# Converting row names to ASV labels
row.names(funguild_mycoparasite_rare.asv)<-funguild_mycoparasite_rare.asv$asv_labels

# Pulling out the ASV table
funguild_mycoparasite_rare.asv_fmt<-select_if(funguild_mycoparasite_rare.asv,is.numeric)

# Adding sample metadata to the ASV table
metadata_funguild_mycoparasite_rare.asv_fmt<-as.data.frame(merge(metadata_phloem,as.data.frame(t(funguild_mycoparasite_rare.asv_fmt)),by.x=0,by.y=0))

# Generating PCoA and ordination plot for fungal plant pathogens without G. morbida
pcoa_all_dates_its_phloem_no_gm_mycoparasite<-pcoa_imager(table = metadata_funguild_mycoparasite_rare.asv_fmt[,!colnames(metadata_funguild_mycoparasite_rare.asv_fmt)%in%geosmithia_labels],method = "bray",point_ellipse_color = "GM",shape = "Treatment",polygon = TRUE,ellipse_fill = "Treatment")

# Plotting G. morbida removed fungal communities in ggplot
pcoa_all_dates_its_phloem_no_gm_mycoparasite_plot<-pcoa_all_dates_its_phloem_no_gm_mycoparasite[2][[1]]+
 # scale_shape_discrete(labels=c("PDA","TN Gm17"))+
  guides(fill=guide_legend("Management Treatment"),shape=guide_legend("Management Treatment"), color=guide_legend("Inoculum"))+
  theme(legend.position = "top")+
  geom_text(data=NULL,inherit.aes=FALSE,aes(x=-0.48,y=0.6,label="Mycoparasites"))
pcoa_all_dates_its_phloem_no_gm_mycoparasite_plot

# Creating a plant pathogen funguild objet that has G. morbida ASVs removed for simplicity
metadata_funguild_mycoparasite_rare.asv_fmt_no_gm<-metadata_funguild_mycoparasite_rare.asv_fmt[,!colnames(metadata_funguild_mycoparasite_rare.asv_fmt)%in%geosmithia_labels]

# Conducting PERMANOVA on plant pathogen communities with G. morbida removed fungal communities
mycoparasite_permanova_its_phloem<-as_tibble(adonis2(select_if(metadata_funguild_mycoparasite_rare.asv_fmt_no_gm,is.numeric)~metadata_funguild_mycoparasite_rare.asv_fmt_no_gm$Treatment*metadata_funguild_mycoparasite_rare.asv_fmt_no_gm$GM*metadata_funguild_mycoparasite_rare.asv_fmt_no_gm$Day, method = "bray",permutations = 9999),rownames = "Variable")

mycoparasite_permanova_its_phloem


# Using grep to pull out only ASVs identified as putative fungal parasite
funguild_woodsaprotroph_rare.asv<-funguild.rare.asv.div.sep[grep("Wood Saprotroph",funguild.rare.asv.div.sep$Guild),]

# Converting row names to ASV labels
row.names(funguild_woodsaprotroph_rare.asv)<-funguild_woodsaprotroph_rare.asv$asv_labels

# Pulling out the ASV table
funguild_woodsaprotroph_rare.asv_fmt<-select_if(funguild_woodsaprotroph_rare.asv,is.numeric)

# Adding sample metadata to the ASV table
metadata_funguild_woodsaprotroph_rare.asv_fmt<-as.data.frame(merge(metadata_phloem,as.data.frame(t(funguild_woodsaprotroph_rare.asv_fmt)),by.x=0,by.y=0))

# Generating PCoA and ordination plot for fungal plant pathogens without G. morbida
pcoa_all_dates_its_phloem_no_gm_woodsaprotroph<-pcoa_imager(table = metadata_funguild_woodsaprotroph_rare.asv_fmt[,!colnames(metadata_funguild_woodsaprotroph_rare.asv_fmt)%in%geosmithia_labels],method = "bray",point_ellipse_color = "GM",shape = "Treatment",polygon = TRUE,ellipse_fill = "Treatment")

# Plotting G. morbida removed fungal communities in ggplot
pcoa_all_dates_its_phloem_no_gm_woodsaprotroph_plot<-pcoa_all_dates_its_phloem_no_gm_woodsaprotroph[2][[1]]+
 # scale_shape_discrete(labels=c("PDA","TN Gm17"))+
  guides(fill=guide_legend("Management Treatment"),shape=guide_legend("Management Treatment"), color=guide_legend("Inoculum"))+
  theme(legend.position = "top")+
  geom_text(data=NULL,inherit.aes=FALSE,aes(x=-0.1,y=0.55,label="Wood Saprotrophs"))
pcoa_all_dates_its_phloem_no_gm_woodsaprotroph_plot

# Creating a plant pathogen funguild objet that has G. morbida ASVs removed for simplicity
metadata_funguild_woodsaprotroph_rare.asv_fmt_no_gm<-metadata_funguild_woodsaprotroph_rare.asv_fmt[,!colnames(metadata_funguild_woodsaprotroph_rare.asv_fmt)%in%geosmithia_labels]

# Conducting PERMANOVA on plant pathogen communities with G. morbida removed fungal communities
woodsaprotroph_permanova_its_phloem<-as_tibble(adonis2(select_if(metadata_funguild_woodsaprotroph_rare.asv_fmt_no_gm,is.numeric)~metadata_funguild_woodsaprotroph_rare.asv_fmt_no_gm$Treatment*metadata_funguild_woodsaprotroph_rare.asv_fmt_no_gm$GM*metadata_funguild_woodsaprotroph_rare.asv_fmt_no_gm$Day, method = "bray",permutations = 9999),rownames = "Variable")

woodsaprotroph_permanova_its_phloem
```

# Fungal Communities Relative Abundance

Generating Relative abundance plots for the total fungal community

```{r}
relative_abundance_plots(metadata = metadata_phloem,taxonomy.table = asv.tax_its_phloem_clean,asv.table = rare.asv.tab_its_phloem,grouping.var = GMTrT,taxon_level = Genus,cut_off = 0.01,kingdom = "Fungi")
```


```{r}
fungal_its_plots<-ggarrange(pcoa_all_dates_its_phloem_plot,pcoa_all_dates_its_phloem_no_gm_plot,align = "h", nrow=2,common.legend = TRUE,labels=c("b","c"))

fungal_its_plots

g.morbida_relabund_gpub<-ggarrange(gmorbida_relabund,labels="a")

fungal_its_plots_gm<-ggarrange(g.morbida_relabund_gpub,fungal_its_plots,nrow=1)

ggarrange(fungal_its_plots_gm,diff_abund_test,nrow=2,heights = c(0.7,0.3))


ggsave("~/Google Drive/My Drive/utk_project/phospho_jet_rootshield_manuscript/manuscript_versions/manuscript_v01/figures/figure_02.tiff",plot=fungal_its_plots_gm,dpi=300,height=10,width=15,bg="white")

funguild_its_plots<-ggarrange(pcoa_all_dates_its_phloem_no_gm_mycoparasite_plot,pcoa_all_dates_its_phloem_no_gm_plantpathogen_plot,pcoa_all_dates_its_phloem_no_gm_woodsaprotroph_plot,nrow=1,common.legend = TRUE,labels=c("a","b","c"))

ggarrange(fungal_its_plots_gm,funguild_its_plots,diff_abund_test,nrow=3)

```


# PIME Random Forest Models

```{r}
# Reading in the rarefied ASV table 
rare.asv.tab_its_phloem<-read.table("~/Google Drive/My Drive/utk_project/phospho_jet_rootshield_manuscript/manuscript_versions/manuscript_v01/analyses/r_sequence_processing_data/feb_23_2024_its_rarefied_asv_table_manuscript_version.txt",header=TRUE,sep='\t')

# Subsetting the ASV table to remove G. morbida ASVs
rare.asv.tab_its_phloem_no_gm<-rare.asv.tab_its_phloem[,!colnames(rare.asv.tab_its_phloem)%in%sub(" ", ".",geosmithia_labels)]

# Creating a phyloseq otu table that has G. morbida removed
rare.asv.tab_phyloseq_no_gm<-phyloseq::otu_table(rare.asv.tab_its_phloem_no_gm,taxa_are_rows = FALSE)

# Creating a phyloseq otu table where G. morbida ASVs are retained
rare.asv.tab_phyloseq_w_gm<-phyloseq::otu_table(rare.asv.tab_its_phloem,taxa_are_rows = FALSE)

# Creating a phyloseq tax table
rare.tax.tab_phyloseq<-phyloseq::tax_table(as.matrix(asv.tax_its_phloem_clean[row.names(asv.tax_its_phloem_clean)%in%colnames(rare.asv.tab_its_phloem),]))

# Creating a phyloseq metadata object
row.names(metadata_phloem)<-metadata_phloem$Tree.ID
rare.sample.metadata_phyloseq<-phyloseq::sample_data(metadata_phloem[metadata_phloem$Tree.ID%in%row.names(rare.asv.tab_its_phloem),])

# Creating a phyloseq object with G. morbida ASVs
rare.asv.tab.tax.meta_phyloseq_w_gm<-phyloseq::phyloseq(rare.asv.tab_phyloseq_w_gm,rare.tax.tab_phyloseq,rare.sample.metadata_phyloseq)

# Creating a phyloseq object without G. morbida ASVs
rare.asv.tab.tax.meta_phyloseq_no_gm<-phyloseq::phyloseq(rare.asv.tab_phyloseq_no_gm,rare.tax.tab_phyloseq,rare.sample.metadata_phyloseq)

# Estimating out of bag error rate for OTU table where G. morbida ASVs were retained
pime.oob.error(rare.asv.tab.tax.meta_phyloseq_w_gm,"GM")

# Estimating out of bag error rate for OTU table where G. morbida ASVs were removed
pime.oob.error(rare.asv.tab.tax.meta_phyloseq_no_gm,"GM")

# Splitting by inoculation type samples where OTU table had G. morbida ASVs
variable_obj_pime_w_gm<-pime.split.by.variable(rare.asv.tab.tax.meta_phyloseq_w_gm,"GM")

# Splitting by inoculation type samples where OTU table had G. morbida ASVs removed
variable_obj_pime_no_gm<-pime.split.by.variable(rare.asv.tab.tax.meta_phyloseq_no_gm,"GM")

# Computing pime prevalence intervals and changes in OOB error rates for OTU table where G. morbida was present
variable_obj_pime_prev_w_gm<-pime.prevalence(variable_obj_pime_w_gm)

# Computing pime prevalence intervals and changes in OOB error rates for OTU table where G. morbida was present
variable_obj_pime_prev_no_gm<-pime.prevalence(variable_obj_pime_no_gm)

# Identifying best PIME prevalence interval to use for phyloseq object that has G. morbida ASVs removed
set.seed(24);
variable_obj_pime_prev_best_no_gm<-pime.best.prevalence(variable_obj_pime_prev_no_gm,"GM")

# Calculating ASV importance for prevalence interval of 75
asv_importance_no_gm<-variable_obj_pime_prev_best_no_gm$'Importance'$`Prevalence 75`

# Generating a phyloseq object for the prevalence interval selected abovee
variable_obj_pime_prev_no_gm_physeq<-variable_obj_pime_prev_no_gm$'75'

# Computing log fold changes of ASVs using ANCOMBC
out_d<-ancombc2(data= rare.asv.tab.tax.meta_phyloseq_no_gm,
         fix_formula="GM+Day+Treatment",
         p_adj_method="fdr",
         prv_cut=0,
         lib_cut=0,
         struc_zero = FALSE,
         neg_lb=FALSE)
res_d<-out_d$res

sig_res_ancombc<-res_d[res_d$`diff_GMTN Gm17`==TRUE,]
sig_res_ancombc

# Creating an ASV table that has the top 10 contributors to model importance 
predictor_asvs_no_gm<-merge(asv_importance_no_gm[1:12,],res_d
,by.x="SequenceID",by.y="taxon")

# Creating a for loop to clean-up ASV names
asv_taxon_names<-c()
for( i in 1:nrow(predictor_asvs_no_gm) ){
  asv_taxon_names<-append(asv_taxon_names,c(if(predictor_asvs_no_gm$Genus[[i]]!="Unassigned"){
      paste0(predictor_asvs_no_gm$SequenceID[[i]],"_",predictor_asvs_no_gm$Genus[[i]])}   
      else if (predictor_asvs_no_gm$Family[[i]]!="Unassigned"){
      paste0(predictor_asvs_no_gm$SequenceID[[i]],"_",predictor_asvs_no_gm$Family[[i]])}
      else{
      paste0(predictor_asvs_no_gm$SequenceID[[i]],"_",predictor_asvs_no_gm$Order[[i]])
      }))
}

predictor_asvs_no_gm$taxon_info<-asv_taxon_names

predictor_asvs_no_gm_sorted<-predictor_asvs_no_gm[order(predictor_asvs_no_gm$MeanDecreaseAccuracy),]

predictor_asvs_no_gm_sorted$taxon_info<-factor(predictor_asvs_no_gm_sorted$taxon_info,levels=predictor_asvs_no_gm_sorted$taxon_info)


mda_rf_no_gm<-ggplot(data=predictor_asvs_no_gm_sorted,aes(x=taxon_info,y=MeanDecreaseAccuracy*100))+
  geom_bar(stat = "identity", width = 0.7, 
           position = position_dodge(width = 0.4))+
  ylab("Mean Decrease in Model Accuracy (%)")+
  xlab(NULL)+
    theme(panel.border = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_line(),axis.line.y=element_line(),axis.ticks=element_line(),axis.line.x=element_line(),panel.background = element_blank(),axis.text.y =element_text( face=ifelse(predictor_asvs_no_gm_sorted$SequenceID%in%funguild_plantpathogen_rare.asv$Row.names,"bold","plain"),color=ifelse(predictor_asvs_no_gm_sorted$SequenceID%in%funguild_plantpathogen_rare.asv$Row.names,"red","black")))+
  coord_flip()
mda_rf_no_gm

lfc_no_gm<-ggplot(data=predictor_asvs_no_gm_sorted,aes(x=taxon_info,y=`lfc_GMTN Gm17`*-1))+
  geom_bar(stat = "identity", width = 0.7, 
           position = position_dodge(width = 0.4),fill=ifelse(predictor_asvs_no_gm_sorted$`lfc_GMTN Gm17`>0,"#F8766D","#00BFC4"))+
    geom_errorbar(aes(ymin = (-`lfc_GMTN Gm17`)-`se_GMTN Gm17`, ymax =  (-`lfc_GMTN Gm17`)+`se_GMTN Gm17`), width = 0.2, color = "black") + 
  ylab("Log Fold Change")+
    theme(panel.border = element_blank(), panel.grid.major = element_blank(), panel.grid.minor = element_blank(),axis.line.y=element_blank(),axis.text.y=element_blank(),axis.ticks=element_blank(),axis.title.y = element_blank(),axis.line.x=element_line(),panel.background = element_blank())+ 
  coord_flip()
  

funguild_its_plots<-ggarrange(pcoa_all_dates_its_phloem_no_gm_woodsaprotroph_plot,pcoa_all_dates_its_phloem_no_gm_plantpathogen_plot,pcoa_all_dates_its_phloem_no_gm_mycoparasite_plot,nrow=1,common.legend = TRUE,legend = "none",labels=c("a","b","c"))

diff_abund_test<-ggarrange(mda_rf_no_gm,lfc_no_gm,labels=c("d","e"),nrow=1)

ggarrange(funguild_its_plots,diff_abund_test,nrow=2)

# Examining how oob error rates change when randomly assigned vs true labeling is used. 1000 bootstraps per prevalence ratio for ASV table where G. morbida was present. 
oob_replication_pime_w_gm<-pime.oob.replicate(variable_obj_pime_prev_w_gm,bootstrap = 1000,variable="GM",parallel=TRUE)

error_prediction_pime_w_gm<-pime.error.prediction(rare.asv.tab.tax.meta_phyloseq_w_gm,"GM",bootstrap=1000,max.prev=95,parallel = TRUE)

# Examining how oob error rates change when randomly assigned vs true labeling is used. 1000 bootstraps per prevalence ratio for ASV table where G. morbida was present. 
oob_replication_pime_no_gm<-pime.oob.replicate(variable_obj_pime_prev_no_gm,bootstrap = 1000,variable="GM",parallel=TRUE)

error_prediction_pime_no_gm<-pime.error.prediction(rare.asv.tab.tax.meta_phyloseq_no_gm,"GM",bootstrap=1000,max.prev=95,parallel = TRUE)

# Plotting error rates. First, changing the 5 to 05 so it shows up first in ggplot. 
oob_replication_pime_w_gm$Plot$data$Prevalence<-sub('^5$','05',oob_replication_pime_w_gm$Plot$data$Prevalence)
error_prediction_pime_no_gm$Plot$data$Prevalence<-sub('^5$','05',error_prediction_pime_no_gm$Plot$data$Prevalence)

oob_replication_pime_w_gm$Plot$data$Prevalence<-sub('^5$','05',oob_replication_pime_w_gm$Plot$data$Prevalence)
oob_replication_pime_w_gm$Plot$data$GM<-"withGm"

oob_replication_pime_gm$Plot$data$Prevalence<-sub('^5$','05',oob_replication_pime_gm$Plot$data$Prevalence)
oob_replication_pime_gm$Plot$data$GM<-"withoutGm"

oob_replication_error<-rbind(oob_replication_pime_gm$Plot$data,oob_replication_pime_gm_w_gm$Plot$data)

error_prediction_pime_gm_w_gm$Plot$data$Prevalence<-sub('^5$','05',error_prediction_pime_gm_w_gm$Plot$data$Prevalence)

ggplot()+
  geom_boxplot(data=oob_replication_error,aes(x=(Prevalence),y=OOBerror*100,fill=GM),outlier.shape = NULL)+
    theme(panel.grid.major=element_blank(),panel.grid.minor=element_blank(),panel.background = element_blank(),panel.border = element_rect(color="black",fill =NA))+
 # scale_y_continuous(limits=c(0,100),breaks=c(0,10,20,30,40,50,60,70,80,90,100))+
  xlab("ASV Prevalence (% of Samples)")+
  ylab("OOB Error (%)")+
  #scale_color_discrete(labels=c("Random Assignment","True Assignment"))+
  guides(colour=guide_legend(title="Assignment"))



```

# Fungal Communities Relative Abundance

Generating Relative abundance plots for the total fungal community

```{r}
relative_abundance_plots(metadata = metadata_phloem,taxonomy.table = asv.tax_its_phloem_clean,asv.table = rare.asv.tab_its_phloem,grouping.var = GMTrT,taxon_level = Genus,cut_off = 0.01,kingdom = "Fungi")
```


```{r}

ggarrange(pcoa_all_dates_its_phloem_plot,gmorbida_relabund,pcoa_all_dates_its_phloem_no_gm_plot,align = "h",labels=c("a","b","c"))

```















```{r}
indicator_analysis_fungal<-multipatt(select_if(metadata.rare.asv.tab_its_phloem,is.numeric),metadata.rare.asv.tab_its_phloem$GMTrT)

indicator_analysis_fungal_results<-as.data.frame(indicator_analysis_fungal$sign)

significant_indicator_analysis_fungal<-indicator_analysis_fungal_results[which(indicator_analysis_fungal_results$p.value<0.05),]

significant_indicator_analysis_fungal_gm<-significant_indicator_analysis_fungal[which(rowSums(significant_indicator_analysis_fungal[,1:3])==0),]

significant_indicator_analysis_fungal_gm_wc<-significant_indicator_analysis_fungal_gm[which((significant_indicator_analysis_fungal_gm[,6])==1),]

significant_indicator_analysis_fungal_gm_only_gm_removed<-subset(significant_indicator_analysis_fungal_gm_wc,!(row.names(significant_indicator_analysis_fungal_gm_wc)%in%sub(" ",".",geosmithia_labels)))

indicator_funguild_gm_only<-merge(funguild_results_phloem_guild_formatted,significant_indicator_analysis_fungal_gm_only_gm_removed,by.x="asv_labels",by.y=0)

significant_indicator_analysis_fungal_pda<-significant_indicator_analysis_fungal[which(rowSums(significant_indicator_analysis_fungal[,4:6])==0),]

significant_indicator_analysis_fungal_pda_wc<-significant_indicator_analysis_fungal_pda[which((significant_indicator_analysis_fungal_pda[,3])==1),]

indicator_funguild_pda_only<-subset(funguild_results_phloem_guild_formatted,funguild_results_phloem_guild_formatted$asv_labels%in%row.names(significant_indicator_analysis_fungal_pda_wc))

significant_indicator_analysis_fungal_pda_gm<-rbind(,significant_indicator_analysis_fungal_gm_only_gm_removed,significant_indicator_analysis_fungal_pda_wc)

metadata.rare.asv.tab_its_phloem_relabund<-metadata.rare.asv.tab_its_phloem

metadata.rare.asv.tab_its_phloem_relabund[,11:length(metadata.rare.asv.tab_its_phloem)]<-decostand(metadata.rare.asv.tab_its_phloem_relabund[,11:length(metadata.rare.asv.tab_its_phloem)],method="total")

metadata.rare.asv.tab_its_phloem_relabund_gm_indic_only<-metadata.rare.asv.tab_its_phloem_relabund[,c(1:10,which(colnames(metadata.rare.asv.tab_its_phloem_relabund)%in%row.names(significant_indicator_analysis_fungal_gm_only_gm_removed)))]

pheatmap::pheatmap(metadata.rare.asv.tab_its_phloem_relabund_gm_indic_only[11:length(metadata.rare.asv.tab_its_phloem_relabund_gm_indic_only)])


significant_indicator_analysis_fungal_pa<-significant_indicator_analysis_fungal[which(rowSums(significant_indicator_analysis_fungal[,c(1,3,4,6)])==0),]

significant_indicator_analysis_fungal_pa_only<-significant_indicator_analysis_fungal_pa[which(rowSums(significant_indicator_analysis_fungal_pa[,c(2,5)])==2),]

```


# Core Fungal Communities Relative Abundance

```{r}
relative_abundance_plots(metadata = metadata_its_phloem,taxonomy.table = prev.filtered.asv.tax_its_phloem,asv.table = prev.filtered.asv.tab_its_phloem,grouping.var = GMTrT,taxon_level = Genus,cut_off = 0.01,kingdom = "Fungi")


```




